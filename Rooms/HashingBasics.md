| [Home](../README.md) | [Cyber Security 101](../README.md#cyber-security-101) | **Hashing Basics** |

## Contents
- [Introduction](#introduction)
- [Hash Functions](#hash-functions)
- [Insecure Password Storage for Authentication](#insecure-password-storage-for-authentication)
- [Using Hashing for Secure Password Storage](#using-hashing-for-secure-password-storage)
- [Recognising Password Hashes](#recognising-password-hashes)
- [Password Cracking](#password-cracking)
- [Hashing for Integrity Checking](#hashing-for-integrity-checking)
- [Conclusion](#conclusion)
## Introduction
### Why Use Hashing?
When you download or receive a large file (e.g., 6 GB), you want to ensure it‚Äôs **identical to the original**. The best way to do this is by comparing hash values.
### What Is a Hash Value?
- A **hash value** is a fixed-length string generated by a hash function.
- The function takes input of any size and produces a consistent-length output.
- If two files have the same hash, they are almost certainly identical.

> ‚ÄúHash‚Äù can refer to the function, the value, or the act of computing it.

### Room Context
This is the third room in the cryptography series:
- **Cryptography Basics**
- **Public Key Cryptography Basics**
- **Hashing Basics** (this room)
### Learning Objectives
By the end of this room, you‚Äôll understand:
- How **hash** functions work and what **collisions** are
- How hashing is used in **authentication systems**
- How to **recognize and crack** stored hash values
- How hashing ensures **data integrity**


## Hash Functions
### What Is a Hash Function?
- A **hash function** takes input data of any size and produces a **fixed-size output** (called a hash or digest).
- It is **not encryption**: there is no key, and it‚Äôs designed to be **one-way**‚Äîyou can‚Äôt reverse it to get the original input.
- A **good hash function** is:
  - Fast to compute
  - Hard to reverse
  - Sensitive to input changes (even 1 bit changes the output drastically)
### üß™ Example: One-Bit Difference
- File 1 contains the letter **T** (`0x54` or `01010100`)
- File 2 contains the letter **U** (`0x55` or `01010101`)
- Despite differing by just **1 bit**, their hashes are completely different:

```bash
md5sum file1.txt  # b9ece18c950afbfa6b0fdbfa4ff731d3
md5sum file2.txt  # 4c614360da93c0a041b22e537de151eb

sha1sum file1.txt # c2c53d66948214258a26ca9ca845d7ac0c17f8e7
sha1sum file2.txt # b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6

sha256sum file1.txt # e632b7095b0bf32c260fa4c539e9fd7b852d0de454e9be26f24d0d6f91d069d3
sha256sum file2.txt # a25513c7e0f6eaa80a3337ee18081b9e2ed09e00af8531c8f7bb2542764027e7
```

- Hash outputs are typically encoded in **hexadecimal** or **base64**.

### Why Is Hashing Important?
- **Data Integrity**: Ensures files haven‚Äôt been altered.
- **Password Security**: Systems store **hashes** of passwords, not the passwords themselves.
- Used in **login systems**, **file verification**, and **digital signatures**.
### What Is a Hash Collision?
- A **collision** occurs when two different inputs produce the **same hash**.
- Due to the **pigeonhole principle**, collisions are inevitable‚Äîbut good hash functions make them **extremely rare** and **hard to engineer**.
#### üß† Pigeonhole Principle
If a hash function outputs 4-bit values, there are only 16 possible hashes. If you hash 21 different inputs, at least two must share a hash.
### Insecure Hash Functions
- **MD5** and **SHA1** are no longer secure due to known collision attacks.
- Examples:
  - MD5 Collision Demo
  - SHA1 Collision (SHAttered)

> üîí Use modern algorithms like **SHA-256** or **SHA-3** for secure applications.

### Question 1 - What is the SHA256 hash of the `passport.jpg` file in `~/Hashing-Basics/Task-2`?
#### Process
Run `sha256sum` against the `passport.jpg` file to get the hash.
```Shell
user@ip-10-10-253-143:~$ cd Hashing-Basics/Task-2
user@ip-10-10-253-143:~/Hashing-Basics/Task-2$ sha256sum passport.jpg 
77148c6f605a8df855f2b764bcc3be749d7db814f5f79134d2aa539a64b61f02  passport.jpg
user@ip-10-10-253-143:~/Hashing-Basics/Task-2$ 
```

Trying this as the answer
#### Answer 1
- `77148c6f605a8df855f2b764bcc3be749d7db814f5f79134d2aa539a64b61f02` ‚úÖ
### Question 2 - What is the output size in bytes of the MD5 hash function?
#### Process
The MD5 has outputs a 16-bit hash. 

Trying this as the answer
#### Answer 2
- `16` ‚úÖ
### Question 3 - If you have an 8-bit hash output, how many possible hash values are there?
#### Process
As per the summary you would make `8` the power of `2` so it would become $\text{2}^\text{8}\text{ = 256}$

Trying this as the answer
#### Answer 3
- `256` ‚úÖ
## Insecure Password Storage for Authentication
### Hashing in Cyber Security: Password Storage & Data Integrity
Hashing plays a crucial role in cyber security, particularly in:
- **Password Storage** (for authentication)
- **Data Integrity**

> ‚ö†Ô∏è Note: This does **not** apply to password managers, which require password retrieval in plaintext. Authentication systems only need to verify knowledge of the password, not retrieve it.

### Insecure Password Storage Practices
Many data breaches stem from poor password storage methods. Here are three common insecure practices:
#### 1. Storing Passwords in Plaintext
- **Example**: RockYou data breach
- **Impact**: Over 14 million plaintext passwords leaked
- **Tool**: `rockyou.txt` is now a common wordlist in Kali Linux
- **Location**: `/usr/share/wordlists/rockyou.txt`

```Shell
wc -l rockyou.txt
# 14344392 rockyou.txt

head rockyou.txt
# 123456
# 12345
# 123456789
# password
# iloveyou
# ...
```

#### 2. Using Deprecated Encryption
- **Example**: Adobe breach
- **Issue**: Used outdated encryption instead of hashing
- **Additional Risk**: Password hints stored in plaintext, often revealing the password
#### 3. Using Insecure Hashing Algorithms
- **Example**: LinkedIn breach (2012)
- **Issue**: Used SHA-1 without salting
- **Why it's bad**: SHA-1 is vulnerable to collision attacks; lack of salting makes hashes easier to crack
### What is Salting?
**Salting** is the process of adding a random value to a password before hashing it. This prevents attackers from using precomputed hash tables (like rainbow tables) to crack passwords.
### Key Takeaways
- Never store passwords in plaintext.
- Avoid deprecated encryption methods.
- Use strong, modern hashing algorithms (e.g., bcrypt, Argon2) with salting.

### Question 1 - What is the 20th password in `rockyou.txt`?
#### Process
We can grap the list using `head`. See the process below.
```Shell
user@ip-10-10-253-143:~/Hashing-Basics/Task-2$ head -n20 /usr/share/wordlists/rockyou.txt 
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
nicole
daniel
babygirl
monkey
lovely
jessica
654321
michael
ashley
qwerty
```

Since we issued the `-n20` argument we know there are 20 lines or results. The last entry in the list is `qwerty`.

Trying this as the answer
#### Answer 1
- `qwerty` ‚úÖ


## Using Hashing for Secure Password Storage
### Using Hashing to Store Passwords
### Why Use Hashing?
Instead of storing passwords directly, we store their **hash values** using a secure hashing function. This ensures:
- Passwords are never stored in plaintext.
- If the database is leaked, attackers must **crack each hash** individually.
### The Problem with Identical Passwords
- Hash functions produce the same output for the same input.
- If two users have the same password, they will have the **same hash**.
- This allows attackers to:
  - Reuse cracked hashes across accounts.
  - Use **Rainbow Tables** to reverse hashes.
### What is a Rainbow Table?
A **Rainbow Table** is a precomputed lookup table of hashes and their corresponding plaintext passwords.

| Hash                                 | Password     |
|--------------------------------------|--------------|
| 02c75fb22c75b23dc963c7eb91a062cc     | zxcvbnm      |
| b0baee9d279d34fa1dfd71aadb908c3f     | 11111        |
| c44a471bd78cc6c2fea32b9fe028d30a     | asdfghjkl    |
| d0199f51d2728db6011945145a1b607a     | basketball   |
| dcddb75469b4b4875094e14561e573d8     | 000000       |
| e10adc3949ba59abbe56e057f20f883e     | 123456       |
| e19d5cd5af0378da05f63f891c7467af     | abcd1234     |
| e99a18c428cb38d5f260853678922e03     | abc123       |
| fcea920f7412b5da7be0cf42b8c93759     | 1234567      |
| 4c5923b6a6fac7b7355f53bfe2b8f8c1     | inS3CyourP4$$|

> Tools like **CrackStation** and **Hashes.com** use massive rainbow tables for fast hash cracking.

### Protecting Against Rainbow Tables: Salting
**Salting** is the process of adding a unique, random value to each password before hashing.
- Ensures even identical passwords produce **different hashes**.
- Salts are stored in the database but **do not need to be secret**.
- Modern hashing algorithms like **Bcrypt**, **Scrypt**, and **Argon2** handle salting automatically.
### Example: Secure Password Storage
1. Choose a secure hashing algorithm: `Argon2`, `Scrypt`, `Bcrypt`, or `PBKDF2`.
2. Generate a unique salt: `Y4UV*^(=go_!`
3. Concatenate password + salt: `AL4RMc10kY4UV*^(=go_!`
4. Hash the result using the chosen algorithm.
5. Store:
   - The resulting hash
   - The salt used
### Why Not Use Encryption?
- Encryption requires storing a **decryption key**.
- If the key is compromised, **all passwords can be decrypted**.
- Hashing is **one-way** and does not require a key, making it more secure for password storage.
### Key Takeaways
- Always hash passwords using a secure algorithm.
- Use a **unique salt** for each user.
- Avoid encryption for password storage due to key management risks.



### Question 1 - Manually check the hash ‚Äú4c5923b6a6fac7b7355f53bfe2b8f8c1‚Äù using the rainbow table above.
#### Process
I was getting ready to search the sites but as stated it was already provided. `4c5923b6a6fac7b7355f53bfe2b8f8c1` = `inS3CyourP4$$`

Trying this as the answer
#### Answer 1
- `inS3CyourP4$$` ‚úÖ
### Question 2 - Crack the hash ‚Äú5b31f93c09ad1d065c0491b764d04933‚Äù using an online tool.
#### Process
Okay I'm going to use [https://hashes.com/en/decrypt/hash] to 'crack the hash'

Result is `tryhackme`.

Trying this as the answer
#### Answer 2
- `tryhackme` ‚úÖ
### Question 3 - Should you encrypt passwords in password-verification systems? `Yea`/`Nay`
#### Process
#### Answer
- `Nay` ‚úÖ


## Recognising Password Hashes




## Password Cracking



## Hashing for Integrity Checking



## Conclusion



