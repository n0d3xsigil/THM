| [Home](../README.md) | [Cyber Security 101](../README.md#cyber-security-101) | **Hashing Basics** |

## Contents
- [Introduction](#introduction)
- [Hash Functions](#hash-functions)
- [Insecure Password Storage for Authentication](#insecure-password-storage-for-authentication)
- [Using Hashing for Secure Password Storage](#using-hashing-for-secure-password-storage)
- [Recognising Password Hashes](#recognising-password-hashes)
- [Password Cracking](#password-cracking)
- [Hashing for Integrity Checking](#hashing-for-integrity-checking)
- [Conclusion](#conclusion)
## Introduction
### Why Use Hashing?
When you download or receive a large file (e.g., 6 GB), you want to ensure it‚Äôs **identical to the original**. The best way to do this is by comparing hash values.
### What Is a Hash Value?
- A **hash value** is a fixed-length string generated by a hash function.
- The function takes input of any size and produces a consistent-length output.
- If two files have the same hash, they are almost certainly identical.

> ‚ÄúHash‚Äù can refer to the function, the value, or the act of computing it.

### Room Context
This is the third room in the cryptography series:
- **Cryptography Basics**
- **Public Key Cryptography Basics**
- **Hashing Basics** (this room)
### Learning Objectives
By the end of this room, you‚Äôll understand:
- How **hash** functions work and what **collisions** are
- How hashing is used in **authentication systems**
- How to **recognize and crack** stored hash values
- How hashing ensures **data integrity**


## Hash Functions
### What Is a Hash Function?
- A **hash function** takes input data of any size and produces a **fixed-size output** (called a hash or digest).
- It is **not encryption**: there is no key, and it‚Äôs designed to be **one-way**‚Äîyou can‚Äôt reverse it to get the original input.
- A **good hash function** is:
  - Fast to compute
  - Hard to reverse
  - Sensitive to input changes (even 1 bit changes the output drastically)
### üß™ Example: One-Bit Difference
- File 1 contains the letter **T** (`0x54` or `01010100`)
- File 2 contains the letter **U** (`0x55` or `01010101`)
- Despite differing by just **1 bit**, their hashes are completely different:

```bash
md5sum file1.txt  # b9ece18c950afbfa6b0fdbfa4ff731d3
md5sum file2.txt  # 4c614360da93c0a041b22e537de151eb

sha1sum file1.txt # c2c53d66948214258a26ca9ca845d7ac0c17f8e7
sha1sum file2.txt # b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6

sha256sum file1.txt # e632b7095b0bf32c260fa4c539e9fd7b852d0de454e9be26f24d0d6f91d069d3
sha256sum file2.txt # a25513c7e0f6eaa80a3337ee18081b9e2ed09e00af8531c8f7bb2542764027e7
```

- Hash outputs are typically encoded in **hexadecimal** or **base64**.

### Why Is Hashing Important?
- **Data Integrity**: Ensures files haven‚Äôt been altered.
- **Password Security**: Systems store **hashes** of passwords, not the passwords themselves.
- Used in **login systems**, **file verification**, and **digital signatures**.
### What Is a Hash Collision?
- A **collision** occurs when two different inputs produce the **same hash**.
- Due to the **pigeonhole principle**, collisions are inevitable‚Äîbut good hash functions make them **extremely rare** and **hard to engineer**.
#### üß† Pigeonhole Principle
If a hash function outputs 4-bit values, there are only 16 possible hashes. If you hash 21 different inputs, at least two must share a hash.
### Insecure Hash Functions
- **MD5** and **SHA1** are no longer secure due to known collision attacks.
- Examples:
  - MD5 Collision Demo
  - SHA1 Collision (SHAttered)

> üîí Use modern algorithms like **SHA-256** or **SHA-3** for secure applications.

### Question 1 - What is the SHA256 hash of the `passport.jpg` file in `~/Hashing-Basics/Task-2`?
#### Process
Run `sha256sum` against the `passport.jpg` file to get the hash.
```Shell
user@ip-10-10-253-143:~$ cd Hashing-Basics/Task-2
user@ip-10-10-253-143:~/Hashing-Basics/Task-2$ sha256sum passport.jpg 
77148c6f605a8df855f2b764bcc3be749d7db814f5f79134d2aa539a64b61f02  passport.jpg
user@ip-10-10-253-143:~/Hashing-Basics/Task-2$ 
```

Trying this as the answer
#### Answer 1
- `77148c6f605a8df855f2b764bcc3be749d7db814f5f79134d2aa539a64b61f02` ‚úÖ
### Question 2 - What is the output size in bytes of the MD5 hash function?
#### Process
The MD5 has outputs a 16-bit hash. 

Trying this as the answer
#### Answer 2
- `16` ‚úÖ
### Question 3 - If you have an 8-bit hash output, how many possible hash values are there?
#### Process
As per the summary you would make `8` the power of `2` so it would become $\text{2}^\text{8}\text{ = 256}$

Trying this as the answer
#### Answer 3
- `256` ‚úÖ
## Insecure Password Storage for Authentication
### Hashing in Cyber Security: Password Storage & Data Integrity
Hashing plays a crucial role in cyber security, particularly in:
- **Password Storage** (for authentication)
- **Data Integrity**

> ‚ö†Ô∏è Note: This does **not** apply to password managers, which require password retrieval in plaintext. Authentication systems only need to verify knowledge of the password, not retrieve it.

### Insecure Password Storage Practices
Many data breaches stem from poor password storage methods. Here are three common insecure practices:
#### 1. Storing Passwords in Plaintext
- **Example**: RockYou data breach
- **Impact**: Over 14 million plaintext passwords leaked
- **Tool**: `rockyou.txt` is now a common wordlist in Kali Linux
- **Location**: `/usr/share/wordlists/rockyou.txt`

```Shell
wc -l rockyou.txt
# 14344392 rockyou.txt

head rockyou.txt
# 123456
# 12345
# 123456789
# password
# iloveyou
# ...
```

#### 2. Using Deprecated Encryption
- **Example**: Adobe breach
- **Issue**: Used outdated encryption instead of hashing
- **Additional Risk**: Password hints stored in plaintext, often revealing the password
#### 3. Using Insecure Hashing Algorithms
- **Example**: LinkedIn breach (2012)
- **Issue**: Used SHA-1 without salting
- **Why it's bad**: SHA-1 is vulnerable to collision attacks; lack of salting makes hashes easier to crack
### What is Salting?
**Salting** is the process of adding a random value to a password before hashing it. This prevents attackers from using precomputed hash tables (like rainbow tables) to crack passwords.
### Key Takeaways
- Never store passwords in plaintext.
- Avoid deprecated encryption methods.
- Use strong, modern hashing algorithms (e.g., bcrypt, Argon2) with salting.

### Question 1 - What is the 20th password in `rockyou.txt`?
#### Process
We can grap the list using `head`. See the process below.
```Shell
user@ip-10-10-253-143:~/Hashing-Basics/Task-2$ head -n20 /usr/share/wordlists/rockyou.txt 
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
nicole
daniel
babygirl
monkey
lovely
jessica
654321
michael
ashley
qwerty
```

Since we issued the `-n20` argument we know there are 20 lines or results. The last entry in the list is `qwerty`.

Trying this as the answer
#### Answer 1
- `qwerty` ‚úÖ


## Using Hashing for Secure Password Storage
### Using Hashing to Store Passwords
### Why Use Hashing?
Instead of storing passwords directly, we store their **hash values** using a secure hashing function. This ensures:
- Passwords are never stored in plaintext.
- If the database is leaked, attackers must **crack each hash** individually.
### The Problem with Identical Passwords
- Hash functions produce the same output for the same input.
- If two users have the same password, they will have the **same hash**.
- This allows attackers to:
  - Reuse cracked hashes across accounts.
  - Use **Rainbow Tables** to reverse hashes.
### What is a Rainbow Table?
A **Rainbow Table** is a precomputed lookup table of hashes and their corresponding plaintext passwords.

| Hash                                 | Password     |
|--------------------------------------|--------------|
| 02c75fb22c75b23dc963c7eb91a062cc     | zxcvbnm      |
| b0baee9d279d34fa1dfd71aadb908c3f     | 11111        |
| c44a471bd78cc6c2fea32b9fe028d30a     | asdfghjkl    |
| d0199f51d2728db6011945145a1b607a     | basketball   |
| dcddb75469b4b4875094e14561e573d8     | 000000       |
| e10adc3949ba59abbe56e057f20f883e     | 123456       |
| e19d5cd5af0378da05f63f891c7467af     | abcd1234     |
| e99a18c428cb38d5f260853678922e03     | abc123       |
| fcea920f7412b5da7be0cf42b8c93759     | 1234567      |
| 4c5923b6a6fac7b7355f53bfe2b8f8c1     | inS3CyourP4$$|

> Tools like **CrackStation** and **Hashes.com** use massive rainbow tables for fast hash cracking.

### Protecting Against Rainbow Tables: Salting
**Salting** is the process of adding a unique, random value to each password before hashing.
- Ensures even identical passwords produce **different hashes**.
- Salts are stored in the database but **do not need to be secret**.
- Modern hashing algorithms like **Bcrypt**, **Scrypt**, and **Argon2** handle salting automatically.
### Example: Secure Password Storage
1. Choose a secure hashing algorithm: `Argon2`, `Scrypt`, `Bcrypt`, or `PBKDF2`.
2. Generate a unique salt: `Y4UV*^(=go_!`
3. Concatenate password + salt: `AL4RMc10kY4UV*^(=go_!`
4. Hash the result using the chosen algorithm.
5. Store:
   - The resulting hash
   - The salt used
### Why Not Use Encryption?
- Encryption requires storing a **decryption key**.
- If the key is compromised, **all passwords can be decrypted**.
- Hashing is **one-way** and does not require a key, making it more secure for password storage.
### Key Takeaways
- Always hash passwords using a secure algorithm.
- Use a **unique salt** for each user.
- Avoid encryption for password storage due to key management risks.



### Question 1 - Manually check the hash ‚Äú4c5923b6a6fac7b7355f53bfe2b8f8c1‚Äù using the rainbow table above.
#### Process
I was getting ready to search the sites but as stated it was already provided. `4c5923b6a6fac7b7355f53bfe2b8f8c1` = `inS3CyourP4$$`

Trying this as the answer
#### Answer 1
- `inS3CyourP4$$` ‚úÖ
### Question 2 - Crack the hash ‚Äú5b31f93c09ad1d065c0491b764d04933‚Äù using an online tool.
#### Process
Okay I'm going to use [https://hashes.com/en/decrypt/hash] to 'crack the hash'

Result is `tryhackme`.

Trying this as the answer
#### Answer 2
- `tryhackme` ‚úÖ
### Question 3 - Should you encrypt passwords in password-verification systems? `Yea`/`Nay`
#### Process
#### Answer
- `Nay` ‚úÖ


## Recognising Password Hashes
### Offensive Security: Hash Identification and Cracking
- **Hash Recognition**:
  - Tools like `hashID` can identify hash types but are unreliable for many formats.
  - Prefixes in hashes improve recognition accuracy.
  - Use context (e.g., source of the hash) alongside tools for better identification.
### Linux Password Hashes
- **Storage Location**:
  - Password hashes are stored in `/etc/shadow` (readable only by root).
  - Previously stored in `/etc/passwd` (readable by all).
- **Shadow File Format**:
  - Each line has 9 colon-separated fields.
  - The second field contains the hashed password in the format:  
    `$prefix$options$salt$hash`.
- **Common Prefixes and Algorithms**:
  | Prefix | Algorithm |
  |--------|-----------|
  | `$y$`  | yescrypt (default, recommended) |
  | `$gy$` | gost-yescrypt |
  | `$7$`  | scrypt |
  | `$2b$`, `$2y$`, `$2a$`, `$2x$` | bcrypt |
  | `$6$`  | sha512crypt |
  | `$md5` | SunMD5 |
  | `$1$`  | md5crypt |
- **Example**:
  - Hash: `$y$j9T$76UzfgEM5PnymhQ7TlJey1$/OOSg64dhfF.TigVPdzqiFang6uZA4QA1pzzegKdVm4`
  - Components:
    - `y`: yescrypt algorithm
    - `j9T`: algorithm parameter
    - `76UzfgEM5PnymhQ7TlJey1`: salt
    - `/OOSg64dhf...`: hash value
### Windows Password Hashes
- **Hash Type**:
  - NTLM (variant of MD4), visually similar to MD4/MD5.
  - Context is essential for correct identification.
- **Storage Location**:
  - Stored in the SAM (Security Accounts Manager).
  - Tools like `mimikatz` can extract them.
- **Hash Types**:
  - NT hashes
  - LM hashes
### Additional Resources
- **Hashcat Example Hashes**:
  - Useful for identifying various hash formats and prefixes.
- **Research**:
  - Critical for identifying unknown or custom hash formats.
### Question 1 - What is the hash size in yescrypt?
#### Process
Initially I looked on the segment for `yescrypt`, there where 5 results, none of which related to the _hash size_. So time to look at the big wide world web.

I did try to take a  look at the [Hashcat Example Hashes](https://hashcat.net/wiki/doku.php?id=example_hashes) but this page is blocked by my employeer.

Google is our friend here. Some results of interest searching for `yescrypt`
- [yescrypt: large-scale password hashing](https://www.openwall.com/presentations/BSidesLjubljana2017-Yescrypt-Large-scale-Password-Hashing/)
  - Loads of good information about how _yescypt_ works, but honestly I didn't have the drive to review all 84 slides to find what I was after
- [Github: openwall / yescrypt](https://github.com/openwall/yescrypt)
  - some references to sha256
Time for a new search, let's go straight for `yescrypt hash size`
- Of course AI Search is trying to tell me the answer, but I'd really like to find it myself.
- [Arch Man pages: crypt.5.en](https://man.archlinux.org/man/crypt.5.en#yescrypt)
 - Result. There is a section on _yescrypt_.

> While yescrypt's strength against password guessing attacks comes from its algorithm design, its cryptographic security is guaranteed by its use of SHA-256 on the outer layer

The hash size for _SHA-256_ is `256`-bits. 

Trying this as the answer
#### Answer 1
- `256` ‚úÖ
### Question 2 - What‚Äôs the Hash-Mode listed for Cisco-ASA MD5?
#### Process
I've googled, I've looked at loads of pages. Nothing firm. Resolved to look at the hint.
üò≠ look at [Hashcat Example Hashes](https://hashcat.net/wiki/doku.php?id=example_hashes) but this page is blocked by my employeer üò≠.

Github to the rescue [GitHub CalfCrusher / has_examples.md](https://gist.github.com/CalfCrusher/6b87a738d0fe7b88e04f4a36eb6d722d).

`Ctrl+F` and search for _Cisco-ASA_ and found:
| Hash-Mode |   Hash-Name   |       Example       |
|-----------|---------------|---------------------|
| `2410`    | Cisco-ASA MD5 | 02dMBMYkTdC5Ziyp:36 |

Trying this as the answer

#### Answer 2
- `2410` ‚úÖ
### Question 3 - What hashing algorithm is used in Cisco-IOS if it starts with $9$?
#### Process
I'm just going to search the same page for `$9$`, although I think this might be in this segment...
... Okay it's not. Back to my new GitHub friend.

There was the following entry:

| Hash-Mode |       Hash-Name       |                            Example                            |
|-----------|-----------------------|---------------------------------------------------------------|
| `9300`    | Cisco-IOS 9 (scrypt)  | $9$2MJBozw/9R3UsU$2lFhcKvpghcyw8deP25GOfyZaagyUOGBymkryvOdfo6 |

`scrypt` could work, it would fit the answer of `_ _ _ _ _ _`. Let's see if we can find anything else on google to help.

This has potential [Understanding the differences between the Cisco password \ secret Types](https://community.cisco.com/t5/networking-knowledge-base/understanding-the-differences-between-the-cisco-password-secret/ta-p/3163238)

Specifically **Type 9**

> Type 9
> These use the SCRYPT hashing algorithm defined in the informational RFC 7914. SCRYPT uses 80-bit salt, 16384 iterations. It‚Äôs very memory expensive to run the algorithm and therefore difficult to crack. Running it once occasionally on a Cisco device is fine though, this is currently the Best Practice Type password to use. I have not proven it but I believe it is possible that the popular tool HashCat is able to decrypt these.
>
> In the running config standard Type 9 start with $9$.
>
> In the running config convoluted Type 9 start with $14$.

Trying this as the answer
#### Answer 3
- `scrypt`


## Password Cracking
### Cracking Password Hashes with Salt
- **Hash Cracking Basics**:
  - Hashes are not encrypted and cannot be decrypted.
  - Cracking involves hashing many inputs (e.g., from `rockyou.txt`) and comparing them to the target hash.
  - If a salt is used, it must be included in the hashing process.
  - Common tools: **Hashcat** and **John the Ripper**.
### GPU Acceleration
- **GPU Advantages**:
  - GPUs have thousands of cores ideal for hash computations.
  - Greatly accelerate cracking for many hash types.
- **GPU-Resistant Algorithms**:
  - Some algorithms (e.g., **Bcrypt**) are designed to resist GPU acceleration.
### Cracking on Virtual Machines (VMs)
- **Limitations**:
  - VMs typically lack direct access to host GPUs.
  - GPU passthrough is possible but complex and performance-degrading.
  - CPU performance is also reduced in VMs.
- **Recommendations**:
  - Run **Hashcat** on the host OS to utilize GPU.
  - **Windows users** can run Hashcat via PowerShell.
  - **John the Ripper** works well in VMs using CPU but performs better on the host OS.
### Practical Cracking Instructions
- **Avoid Online Rainbow Tables**:
  - Use local tools for a better learning experience.
- **Hashcat Syntax**:
  ```Shell
  hashcat -m <hash_type> -a <attack_mode> hashfile wordlist
  ```
  - `-m <hash_type>`: Numeric code for the hash type (e.g., `-m 1000` for NTLM).
  - `-a <attack_mode>`: Attack mode (e.g., `-a 0` for straight wordlist attack).
  - `hashfile`: File containing the hash to crack.
  - `wordlist`: File with potential passwords (e.g., `rockyou.txt`).

- **Example**:
  ```Shell
  hashcat -m 3200 -a 0 hash.txt /usr/share/wordlists/rockyou.txt
  ```
  - Treats the hash as **Bcrypt** and uses `rockyou.txt` for cracking.

### Question 1 - Use `hashcat` to crack the hash, `$2a$06$7yoU3Ng8dHTXphAg913cyO6Bjs3K5lBnwq5FJyA6d01pMSrddr1ZG`, saved in `~/Hashing-Basics/Task-6/hash1.txt`.
#### Process
Found $2a$ was bcyrpt. Mode 3200

Used example in page `hashcat -m 3200 -a 0 hash1.txt`. Ran for 10 minutes, kept getting warnings about std input too slow/

Crap

Used example in page correctly `hashcat -m 3200 -a 0 hash1.txt /usr/share/wordlists/rockyou.txt`

Cracked `85208520`

Trying this as the answer
#### Answer 1
- `85208520` ‚úÖ
### Question 2 - Use `hashcat` to crack the SHA2-256 hash, `9eb7ee7f551d2f0ac684981bd1f1e2fa4a37590199636753efe614d4db30e8e1`, saved in saved in `~/Hashing-Basics/Task-6/hash2.txt`.
#### Process
Find Hash-mode for SHA2-256

| Hash-Mode	| Hash-Name |
|-----------|-----------|
|    `1400` | SHA2-256  |

-m 1400.

Build command `hashcat -m 1400 -a 0 hash2.txt /usr/share/wordlists/rockyou.txt`

full output below

```Shell
user@ip-10-10-173-238:~/Hashing-Basics/Task-6$ hashcat -m 1400 -a 0 hash2.txt /usr/share/wordlists/rockyou.txt 
hashcat (v6.2.6) starting

OpenCL API (OpenCL 3.0 PoCL 5.0+debian  Linux, None+Asserts, RELOC, SPIR, LLVM 16.0.6, SLEEF, DISTRO, POCL_DEBUG) - Platfor
m #1 [The pocl project]
===========================================================================================================================
=======================
* Device #1: cpu-haswell-AMD EPYC 7571, 1418/2901 MB (512 MB allocatable), 2MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

Hashes: 1 digests; 1 unique digests, 1 unique salts
Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotates
Rules: 1

Optimizers applied:
* Zero-Byte
* Early-Skip
* Not-Salted
* Not-Iterated
* Single-Hash
* Single-Salt
* Raw-Hash

ATTENTION! Pure (unoptimized) backend kernels selected.
Pure kernels can crack longer passwords, but drastically reduce performance.
If you want to switch to optimized kernels, append -O to your commandline.
See the above message to find out about the exact limits.

Watchdog: Temperature abort trigger set to 90c

Host memory required for this attack: 0 MB

Dictionary cache hit:
* Filename..: /usr/share/wordlists/rockyou.txt
* Passwords.: 14344384
* Bytes.....: 139921497
* Keyspace..: 14344384

9eb7ee7f551d2f0ac684981bd1f1e2fa4a37590199636753efe614d4db30e8e1:halloween
                                                          
Session..........: hashcat
Status...........: Cracked
Hash.Mode........: 1400 (SHA2-256)
Hash.Target......: 9eb7ee7f551d2f0ac684981bd1f1e2fa4a37590199636753efe...30e8e1
Time.Started.....: Wed Jun 11 12:06:30 2025 (0 secs)
Time.Estimated...: Wed Jun 11 12:06:30 2025 (0 secs)
Kernel.Feature...: Pure Kernel
Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:    38589 H/s (0.21ms) @ Accel:256 Loops:1 Thr:1 Vec:8
Recovered........: 1/1 (100.00%) Digests (total), 1/1 (100.00%) Digests (new)
Progress.........: 3072/14344384 (0.02%)
Rejected.........: 0/3072 (0.00%)
Restore.Point....: 2560/14344384 (0.02%)
Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:0-1
Candidate.Engine.: Device Generator
Candidates.#1....: gators -> dangerous
Hardware.Mon.#1..: Util: 50%

Started: Wed Jun 11 12:05:39 2025
Stopped: Wed Jun 11 12:06:31 2025
user@ip-10-10-173-238:~/Hashing-Basics/Task-6$ 
```

The line we are interested in is `9eb7ee7f551d2f0ac684981bd1f1e2fa4a37590199636753efe614d4db30e8e1:halloween`

Specifically `halloween`

Trying this as the answer

#### Answer 2
- `halloween` ‚úÖ
### Question 3 - Use `hashcat` to crack the hash, `$6$GQXVvW4EuM$ehD6jWiMsfNorxy5SINsgdlxmAEl3.yif0/c3NqzGLa0P.S7KRDYjycw5bnYkF5ZtB8wQy8KnskuWQS3Yr1wQ0`, saved in `~/Hashing-Basics/Task-6/hash3.txt`.
#### Process
Searching for `$6$` within the GitHub hashes

Found:
| Hash-Mode	|             Hash-Name             |
|-----------|-----------------------------------|
|    `1800` | sha512crypt 6, SHA512 (Unix) [^2] |

So lets try mode `1800` by issuing `hashcat -m 1800  -a 0 hash3.txt /usr/share/wordlists/rockyou.txt`

Results below:
```Shell
user@ip-10-10-173-238:~/Hashing-Basics/Task-6$ hashcat -m 1800 -a 0 hash3.txt /usr/share/wordlists/rockyou.txt 
hashcat (v6.2.6) starting

OpenCL API (OpenCL 3.0 PoCL 5.0+debian  Linux, None+Asserts, RELOC, SPIR, LLVM 16.0.6, SLEEF, DISTRO, POCL_DEBUG) - Platfor
m #1 [The pocl project]
===========================================================================================================================
=======================
* Device #1: cpu-haswell-AMD EPYC 7571, 1418/2901 MB (512 MB allocatable), 2MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

Hashes: 1 digests; 1 unique digests, 1 unique salts
Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotates
Rules: 1

Optimizers applied:
* Zero-Byte
* Single-Hash
* Single-Salt
* Uses-64-Bit

ATTENTION! Pure (unoptimized) backend kernels selected.
Pure kernels can crack longer passwords, but drastically reduce performance.
If you want to switch to optimized kernels, append -O to your commandline.
See the above message to find out about the exact limits.

Watchdog: Temperature abort trigger set to 90c

Host memory required for this attack: 0 MB

Dictionary cache hit:
* Filename..: /usr/share/wordlists/rockyou.txt
* Passwords.: 14344384
* Bytes.....: 139921497
* Keyspace..: 14344384

Cracking performance lower than expected?                 

* Append -O to the commandline.
  This lowers the maximum supported password/salt length (usually down to 32).

* Append -w 3 to the commandline.
  This can cause your screen to lag.

* Append -S to the commandline.
  This has a drastic speed impact but can be better for specific attacks.
  Typical scenarios are a small wordlist but a large ruleset.

* Update your backend API runtime / driver the right way:
  https://hashcat.net/faq/wrongdriver

* Create more work items to make use of your parallelization power:
  https://hashcat.net/faq/morework

$6$GQXVvW4EuM$ehD6jWiMsfNorxy5SINsgdlxmAEl3.yif0/c3NqzGLa0P.S7KRDYjycw5bnYkF5ZtB8wQy8KnskuWQS3Yr1wQ0:spaceman
                                                          
Session..........: hashcat
Status...........: Cracked
Hash.Mode........: 1800 (sha512crypt $6$, SHA512 (Unix))
Hash.Target......: $6$GQXVvW4EuM$ehD6jWiMsfNorxy5SINsgdlxmAEl3.yif0/c3...Yr1wQ0
Time.Started.....: Wed Jun 11 13:16:53 2025 (54 secs)
Time.Estimated...: Wed Jun 11 13:17:47 2025 (0 secs)
Kernel.Feature...: Pure Kernel
Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:      347 H/s (9.05ms) @ Accel:64 Loops:256 Thr:1 Vec:4
Recovered........: 1/1 (100.00%) Digests (total), 1/1 (100.00%) Digests (new)
Progress.........: 18496/14344384 (0.13%)
Rejected.........: 0/18496 (0.00%)
Restore.Point....: 18432/14344384 (0.13%)
Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:4864-5000
Candidate.Engine.: Device Generator
Candidates.#1....: sunshine13 -> mandingo
Hardware.Mon.#1..: Util: 93%

Started: Wed Jun 11 13:15:51 2025
Stopped: Wed Jun 11 13:17:48 2025
user@ip-10-10-173-238:~/Hashing-Basics/Task-6$ 
```
Again our magic result is `$6$GQXVvW4EuM$ehD6jWiMsfNorxy5SINsgdlxmAEl3.yif0/c3NqzGLa0P.S7KRDYjycw5bnYkF5ZtB8wQy8KnskuWQS3Yr1wQ0:spaceman`.
Specifically `spaceman`.
- [x] Trying this as the anwer
#### Answer 3
- `spaceman` ‚úÖ
### Question 4 - Crack the hash, `b6b0d451bbf6fed658659a9e7e5598fe`, saved in `~/Hashing-Basics/Task-6/hash4.txt`.
#### Process
My gut says MD5. Which is _Hash-Mode_ `0`. Lets try that (`hashcat -m 0 -a 0 hash4.txt /user/share/wordlists/rockyoutxt`)first and see if it works...

Well, that didn't work (see below). So let's do a little digging and go from there
```Shell
user@ip-10-10-173-238:~/Hashing-Basics/Task-6$ hashcat -m 0 -a 0 hash4.txt /usr/share/wordlists/rockyou.txt 
hashcat (v6.2.6) starting

OpenCL API (OpenCL 3.0 PoCL 5.0+debian  Linux, None+Asserts, RELOC, SPIR, LLVM 16.0.6, SLEEF, DISTRO, POCL_DEBUG) - Platfor
m #1 [The pocl project]
===========================================================================================================================
=======================
* Device #1: cpu-haswell-AMD EPYC 7571, 1418/2901 MB (512 MB allocatable), 2MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

Hashes: 1 digests; 1 unique digests, 1 unique salts
Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotates
Rules: 1

Optimizers applied:
* Zero-Byte
* Early-Skip
* Not-Salted
* Not-Iterated
* Single-Hash
* Single-Salt
* Raw-Hash

ATTENTION! Pure (unoptimized) backend kernels selected.
Pure kernels can crack longer passwords, but drastically reduce performance.
If you want to switch to optimized kernels, append -O to your commandline.
See the above message to find out about the exact limits.

Watchdog: Temperature abort trigger set to 90c

Host memory required for this attack: 0 MB

Dictionary cache hit:
* Filename..: /usr/share/wordlists/rockyou.txt
* Passwords.: 14344384
* Bytes.....: 139921497
* Keyspace..: 14344384

Cracking performance lower than expected?                 

* Append -O to the commandline.
  This lowers the maximum supported password/salt length (usually down to 32).

* Append -w 3 to the commandline.
  This can cause your screen to lag.

* Append -S to the commandline.
  This has a drastic speed impact but can be better for specific attacks.
  Typical scenarios are a small wordlist but a large ruleset.

* Update your backend API runtime / driver the right way:
  https://hashcat.net/faq/wrongdriver

* Create more work items to make use of your parallelization power:
  https://hashcat.net/faq/morework

Approaching final keyspace - workload adjusted.           

Session..........: hashcat                                
Status...........: Exhausted
Hash.Mode........: 0 (MD5)
Hash.Target......: b6b0d451bbf6fed658659a9e7e5598fe
Time.Started.....: Wed Jun 11 13:23:44 2025 (11 secs)
Time.Estimated...: Wed Jun 11 13:23:55 2025 (0 secs)
Kernel.Feature...: Pure Kernel
Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:  1161.3 kH/s (0.17ms) @ Accel:256 Loops:1 Thr:1 Vec:8
Recovered........: 0/1 (0.00%) Digests (total), 0/1 (0.00%) Digests (new)
Progress.........: 14344384/14344384 (100.00%)
Rejected.........: 0/14344384 (0.00%)
Restore.Point....: 14344384/14344384 (100.00%)
Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:0-1
Candidate.Engine.: Device Generator
Candidates.#1....: $HEX[206b6d3831303838] -> $HEX[042a0337c2a156616d6f732103]
Hardware.Mon.#1..: Util: 50%

Started: Wed Jun 11 13:23:11 2025
Stopped: Wed Jun 11 13:23:56 2025
user@ip-10-10-173-238:~/Hashing-Basics/Task-6$ 
```

So the hash starts with `b6b` so let's check that against the hash examples.

Curious, NTLM is 32bit, the start is `b#b` so may work. Lets try (hashcat -m 1000 -a 0 hash4.txt /usr/share/wordlists/rockyou.txt) next, the results are below
```Shell
user@ip-10-10-173-238:~/Hashing-Basics/Task-6$ ^C
user@ip-10-10-173-238:~/Hashing-Basics/Task-6$ hashcat -m 1000 -a 0 hash4.txt /usr/share/wordlists/rockyou.txt 
hashcat (v6.2.6) starting

OpenCL API (OpenCL 3.0 PoCL 5.0+debian  Linux, None+Asserts, RELOC, SPIR, LLVM 16.0.6, SLEEF, DISTRO, POCL_DEBUG) - Platfor
m #1 [The pocl project]
===========================================================================================================================
=======================
* Device #1: cpu-haswell-AMD EPYC 7571, 1418/2901 MB (512 MB allocatable), 2MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

Hashes: 1 digests; 1 unique digests, 1 unique salts
Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotates
Rules: 1

Optimizers applied:
* Zero-Byte
* Early-Skip
* Not-Salted
* Not-Iterated
* Single-Hash
* Single-Salt
* Raw-Hash

ATTENTION! Pure (unoptimized) backend kernels selected.
Pure kernels can crack longer passwords, but drastically reduce performance.
If you want to switch to optimized kernels, append -O to your commandline.
See the above message to find out about the exact limits.

Watchdog: Temperature abort trigger set to 90c

Host memory required for this attack: 0 MB

Dictionary cache hit:
* Filename..: /usr/share/wordlists/rockyou.txt
* Passwords.: 14344384
* Bytes.....: 139921497
* Keyspace..: 14344384

Cracking performance lower than expected?                 

* Append -O to the commandline.
  This lowers the maximum supported password/salt length (usually down to 32).

* Append -w 3 to the commandline.
  This can cause your screen to lag.

* Append -S to the commandline.
  This has a drastic speed impact but can be better for specific attacks.
  Typical scenarios are a small wordlist but a large ruleset.

* Update your backend API runtime / driver the right way:
  https://hashcat.net/faq/wrongdriver

* Create more work items to make use of your parallelization power:
  https://hashcat.net/faq/morework

Approaching final keyspace - workload adjusted.           

Session..........: hashcat                                
Status...........: Exhausted
Hash.Mode........: 1000 (NTLM)
Hash.Target......: b6b0d451bbf6fed658659a9e7e5598fe
Time.Started.....: Wed Jun 11 13:29:47 2025 (9 secs)
Time.Estimated...: Wed Jun 11 13:29:56 2025 (0 secs)
Kernel.Feature...: Pure Kernel
Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:  1596.1 kH/s (0.10ms) @ Accel:256 Loops:1 Thr:1 Vec:8
Recovered........: 0/1 (0.00%) Digests (total), 0/1 (0.00%) Digests (new)
Progress.........: 14344384/14344384 (100.00%)
Rejected.........: 0/14344384 (0.00%)
Restore.Point....: 14344384/14344384 (100.00%)
Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:0-1
Candidate.Engine.: Device Generator
Candidates.#1....: $HEX[206b6d3831303838] -> $HEX[042a0337c2a156616d6f732103]
Hardware.Mon.#1..: Util: 33%

Started: Wed Jun 11 13:29:17 2025
Stopped: Wed Jun 11 13:29:58 2025
```
Nothing to see here. Okay no worries, onward and upwards So in the previous segment, we mentioned that NTLM hashes re visually identical to MD4 and MD5 hashes. Is that something to bear in mind?

So I tried to run **hashcat** without a mode. It did the following:
```Shell
user@ip-10-10-173-238:~/Hashing-Basics/Task-6$ hashcat -a 0 hash4.txt /usr/share/wordlists/rockyou.txt 
hashcat (v6.2.6) starting in autodetect mode

OpenCL API (OpenCL 3.0 PoCL 5.0+debian  Linux, None+Asserts, RELOC, SPIR, LLVM 16.0.6, SLEEF, DISTRO, POCL_DEBUG) - Platfor
m #1 [The pocl project]
===========================================================================================================================
=======================
* Device #1: cpu-haswell-AMD EPYC 7571, 1418/2901 MB (512 MB allocatable), 2MCU

The following 11 hash-modes match the structure of your input hash:

      # | Name                                                       | Category
  ======+============================================================+======================================
    900 | MD4                                                        | Raw Hash
      0 | MD5                                                        | Raw Hash
     70 | md5(utf16le($pass))                                        | Raw Hash
   2600 | md5(md5($pass))                                            | Raw Hash salted and/or iterated
   3500 | md5(md5(md5($pass)))                                       | Raw Hash salted and/or iterated
   4400 | md5(sha1($pass))                                           | Raw Hash salted and/or iterated
  20900 | md5(sha1($pass).md5($pass).sha1($pass))                    | Raw Hash salted and/or iterated
   4300 | md5(strtoupper(md5($pass)))                                | Raw Hash salted and/or iterated
   1000 | NTLM                                                       | Operating System
   9900 | Radmin2                                                    | Operating System
   8600 | Lotus Notes/Domino 5                                       | Enterprise Application Software (EAS)

Please specify the hash-mode with -m [hash-mode].

Started: Wed Jun 11 13:35:04 2025
Stopped: Wed Jun 11 13:35:09 2025
```
Which is good, this has given me a breakdown of the potential hash modes to look at. I don't think it is any of the salted hashes. 

Rather than spend too much more time I decided to just google the hash (`b6b0d451bbf6fed658659a9e7e5598fe`).

First link [md5hashing.net](https://md5hashing.net/hash/md5/b6b0d451bbf6fed658659a9e7e5598fe) gave me what I was after. 
![image](https://github.com/user-attachments/assets/08c340f4-7d9b-42e2-8c3e-c66628c403e7)

Let's see if my initial gut instinct was right by calling it MD5 and try `funforyou`

Trying that as the answer
#### Answer 4
- `funforyou` ‚úÖ
## Hashing for Integrity Checking
### Integrity Checking with Hashing
- **Purpose**:
  - Hashing verifies that files haven‚Äôt been altered.
  - Even a 1-bit change results in a completely different hash.
  - Useful for confirming file integrity after downloads.
- **Example**:
  - A SHA256 checksum file lists official hashes for Fedora ISO files.
  - If your computed hash matches the listed one, the file is unmodified.
- **Command Example**:
  ```bash
  sha256sum <filename>
  ```
  - Compare the output with the official hash to verify integrity.
- **Duplicate Detection**:
  - Identical hashes indicate identical files.
  - Useful for identifying and removing duplicate files.
### HMACs (Keyed-Hash Message Authentication Codes)
- **Purpose**:
  - Ensures both **authenticity** (sender is verified) and **integrity** (message is unaltered).
  - Combines a cryptographic hash function with a **secret key**.
- **How HMAC Works**:

![image](https://github.com/user-attachments/assets/ab7f6381-9e48-4426-9d78-4e1eab9e7a30)
  1. Pad the secret key to the hash function‚Äôs block size.
  2. XOR the padded key with a constant (e.g., `ipad` or `opad`).
  3. Hash the message with the XORed key.
  4. Hash the result again with the other XORed key.
  5. Output is the final HMAC value.
- **Formula**:
  ```
  HMAC(K, M) = H((K ‚äï opad) || H((K ‚äï ipad) || M))
  ```
  - `K`: secret key  
  - `M`: message  
  - `H`: hash function  
  - `‚äï`: XOR  
  - `||`: concatenation
### Question 1 - What is SHA256 hash of `libgcrypt-1.11.0.tar.bz2` found in `~/Hashing-Basics/Task-7`?
#### Process
Should be straight forward, we'll use `sha256sum <filename>` and that should give us our answer.

<Just waiting for machine to start...>
```Shell
user@ip-10-10-150-202:~$ sha256sum Hashing-Basics/Task-7/libgcrypt-1.11.0.tar.bz2 
09120c9867ce7f2081d6aaa1775386b98c2f2f246135761aae47d81f58685b9c  Hashing-Basics/Task-7/libgcrypt-1.11.0.tar.bz2
```

We have a sum of `09120c9867ce7f2081d6aaa1775386b98c2f2f246135761aae47d81f58685b9c`

Trying that as the answer
#### Answer 1
- `09120c9867ce7f2081d6aaa1775386b98c2f2f246135761aae47d81f58685b9c` ‚úÖ
### Question 2 - What‚Äôs the hashcat mode number for `HMAC-SHA512 (key = $pass)`?
#### Process
Again, fairly straight forward, this is the salted hash. I'll use the GitHub hash examples as I can't access Hastcat at the moment.

| Hash-Mode	|         Hash-Name         |
|-----------|---------------------------|
|    `1750` | HMAC-SHA512 (key = $pass) |


Trying this as the answer
#### Answer 2
- `1750` ‚úÖ
## Conclusion



